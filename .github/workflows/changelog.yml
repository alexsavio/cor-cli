name: Changelog

on:
  push:
    branches:
      - main
    paths-ignore:
      - 'CHANGELOG.md'
      - '.github/workflows/changelog.yml'

  workflow_dispatch:

permissions:
  contents: write

jobs:
  changelog:
    name: Update Changelog
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Install git-cliff
        uses: taiki-e/install-action@v2
        with:
          tool: git-cliff@2.12.0

      - name: Merge new entries into changelog
        run: |
          python3 << 'PYEOF'
          import re, subprocess, sys

          # Generate unreleased section from git history
          result = subprocess.run(
              ["git", "cliff", "--unreleased", "--strip", "all"],
              capture_output=True, text=True, check=True,
          )
          generated = result.stdout

          with open("CHANGELOG.md") as f:
              changelog = f.read()

          # Collect generated entries per group (### heading)
          gen_groups = {}
          current_group = None
          for line in generated.splitlines():
              if line.startswith("### "):
                  current_group = line
                  gen_groups.setdefault(current_group, [])
              elif current_group and line.startswith("- "):
                  gen_groups[current_group].append(line)

          if not gen_groups:
              print("No new unreleased entries from git-cliff, nothing to do.")
              sys.exit(0)

          # Find the [Unreleased] section boundaries
          unreleased_re = re.compile(r"^## \[Unreleased\]\s*$", re.MULTILINE)
          next_release_re = re.compile(r"^## \[(?!Unreleased)", re.MULTILINE)

          match = unreleased_re.search(changelog)
          if not match:
              # No [Unreleased] section — insert one before the first release
              first_release = next_release_re.search(changelog)
              insert_pos = first_release.start() if first_release else len(changelog)
              section = "## [Unreleased]\n\n"
              for group, entries in gen_groups.items():
                  section += f"{group}\n\n"
                  for entry in entries:
                      section += f"{entry}\n"
                  section += "\n"
              changelog = changelog[:insert_pos] + section + changelog[insert_pos:]
          else:
              # Find end of [Unreleased] section
              rest_start = match.end()
              next_release = next_release_re.search(changelog[rest_start:])
              section_end = rest_start + next_release.start() if next_release else len(changelog)

              existing_section = changelog[rest_start:section_end]

              # Collect existing entries for deduplication
              existing_entries = set()
              for line in existing_section.splitlines():
                  stripped = line.strip()
                  if stripped.startswith("- "):
                      existing_entries.add(stripped)

              # For each generated group, find entries not already present
              appended_groups = ""
              for group, entries in gen_groups.items():
                  new_entries = [e for e in entries if e.strip() not in existing_entries]
                  if not new_entries:
                      continue

                  group_pattern = re.escape(group)
                  group_match = re.search(
                      f"^{group_pattern}\\s*$", existing_section, re.MULTILINE,
                  )
                  if group_match:
                      # Find last "- " entry in this group
                      after_group = existing_section[group_match.end():]
                      last_entry_offset = group_match.end()
                      for m in re.finditer(r"^- .+$", after_group, re.MULTILINE):
                          # Stop if we hit a ### heading first
                          preceding = after_group[:m.start()]
                          if re.search(r"^### ", preceding, re.MULTILINE):
                              break
                          last_entry_offset = group_match.end() + m.end()

                      insert_offset = rest_start + last_entry_offset
                      insert_text = "\n"
                      for entry in new_entries:
                          insert_text += f"{entry}\n"

                      changelog = (
                          changelog[:insert_offset]
                          + insert_text
                          + changelog[insert_offset:]
                      )
                      section_end += len(insert_text)
                      existing_section = changelog[rest_start:section_end]
                  else:
                      # Group doesn't exist — will be appended at end
                      appended_groups += f"\n{group}\n\n"
                      for entry in new_entries:
                          appended_groups += f"{entry}\n"

              if appended_groups:
                  changelog = (
                      changelog[:section_end]
                      + appended_groups + "\n"
                      + changelog[section_end:]
                  )

          with open("CHANGELOG.md", "w") as f:
              f.write(changelog)

          print("Changelog updated successfully.")
          PYEOF

      - name: Install rumdl
        run: cargo install rumdl

      - name: Format changelog
        run: rumdl fmt CHANGELOG.md

      - name: Commit updated changelog
        run: |
          git diff --quiet CHANGELOG.md && exit 0
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add CHANGELOG.md
          git commit -m "chore: update changelog [skip ci]"
          git pull --rebase
          git push
